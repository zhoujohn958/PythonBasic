---

# Python：函数、封包解包、命名空间与作用域

---

## 一、函数

### 1. 定义函数

```python
def func_name([arg1 [, arg2, ... argN]]): 
    func_body
```

* **形参**：函数定义时声明的参数
* **实参**：函数调用时传入的参数
* 函数只需要定义一次，可多次调用
* 调用时执行，定义时不执行

```python
def plus(num):
    print(num + 1)

plus(2)  # 3
plus(5)  # 6

f = plus
print(plus)
print(f)
f(2)  # 3
f(5)  # 6
```

---

### 2. `return` 用法

* `return` 将对象返回给调用方并结束函数
* 可以返回单个、多个对象，甚至不返回（等价于 `return None`）

```python
# 返回一个对象
def add1(left, right):
    res = left + right
    return res
print(add1(3, 4))

def add2(left, right):
    return left + right
print(add2(3, 4))

# 返回多个对象, 自动打包成一个元组
def add3(left, right):
    res1 = left + right
    res2 = left * right
    return res1, res2
print(add3(3, 4))

def add4(left, right):
    return left + right, left * right
print(add4(3, 4))

# return None 
def add5(left, right):
    print(left + right)
print(add5(3, 4))

def add6(left, right):
    pass
print(add6(3, 4))

```
---

## 二、参数传递

### 1. 可变 & 不可变对象
```python
def func(b):
    print(id(a), a)
    print(id(b), b)

# 传不可变参数，id地址和值相同 
a = 789
func(a)

# 传可变参数，id地址和值相同 
a = [789]
func(a)

def func(b):
    print(b)
    b.append(345)
    print(b)

a = [789]
func(a)
print(a)

def func(b):
    print(id(a), a)
    print(id(b), b)

a = [789]
func(a)
```

---

## 三、参数分类

### 1. 必需参数
* 必须接收一个实参的形参，多了少了都不行
```python
def func(a, b):
    print(a - b)
func(3, 4)
func(3, b=4)
func(a=3, b=4)
```

### 2. 位置参数 & 关键字参数
* 位置参数：按照从左往右的顺序将实参传递给对应的形参

```python
def func(a, b):
    print(a - b)
func(3, 4)  # -1
func(4, 3)  # 1
```
关键字参数：
* 按照指定的名称将实参传递给对应的形参，与位置顺序无关
* 关键字参数必须放在位置参数的后面
```python
def func(a, b):
    print(a - b)
func(a=3, b=4)  # -1
func(b=4, a=3)  # -1
func(3, b=4)    # -1
```

### 3. 默认参数
* 有接收到实参，使用实参，没有接收到实参时，才会使用默认值
```python
def func(a, b=4):
    print(a - b)

func(3)    # -1
func(3, 5) # -2
```

### 4. 不定长参数
* *args：接收[0, +∞)个位置参数，贪婪的，将它们打包成一个元组，如果没有接收到实参，则为空元组。
* **kwargs：接收[0, +∞)个关键字参数，贪婪的，将它们打包成一个字典，如果没有接收到实参，则为空字典。必须放在所有形参的最后。

```python
def func(*args):
    print(args)

func()
func(3, 1, 4, 6)

def func(**kwargs):
    print(kwargs)

func()
func(a=3, b=2, c=4)

def func(*args, **kwargs):
    print(args)
    print(kwargs)

func(1, 2, a=3, b=4)
```

---

### 5. 特殊参数：`/` 和 `*`
* 默认情况下，实参的传递形式可以是位置参数或关键字参数
* 可以用 / 和 * 来限制参数的传递形式
* 其中 / 为仅限位置参数，限制在它之前的形参只能接收位置参数
* 其中 * 为仅限关键字参数，限制在它之后的形参只能接收关键字参数
* 这两个特殊参数只是为了限制参数的传递形式，不需要为它们传入实参


```python
def func(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
    pass

func(1, 2, 3, kwd1=4, kwd2=5)
func(1, 2, pos_or_kwd=3, kwd1=4, kwd2=5)
```

---

## 四、匿名函数 lambda
* 格式： lambda [arg1 [, arg2, ... argN]] : expression
* 匿名函数的参数可以有多个，但是后面的 expression 只能有一个
* 匿名函数返回值就是 expression 的结果，而不需要使用return
* 匿名函数可以在需要函数对象的地方使用（如：赋值给变量、作为参数传入其他函数等），因为匿名函数可以作为一个表达式，而不是一个结构化的代码块

```python
lambda [arg1 [, arg2, ... argN]] : expression
```

示例：

```python
f = lambda: 'It just returns a string'
print(f())

f = lambda x, y, z: print(x + y + z)
f(1, 2, 3)

tup = (8, 5, -9, 6, 2)
print(sorted(tup, key=lambda x: -x if x < 0 else x))
```

---

## 五、封包与解包

### 1. 封包（Packing）
* 将多个值同时赋值给一个变量时，会自动将这些值打包成一个元组
```python
tup = 1, 2, 3  # 自动打包成元组
```

### 2. 解包（Unpacking）
解包是针对可迭代对象的操作

* 赋值过程中的解包
```python
a, b, c = [4, 3, 'a']
print(a)   # 4
print(b)   # 3
print(c)   # 'a'

a, *b, c = 'hello'
print(a)  # 'h'
print(b)  # ['e', 'l', 'l']
print(c)  # 'o'

a, *b, c = 'he'
print(a)  # 'h'
print(b)  # []
print(c)  # 'e'

*a, = 'hel'
print(a)  # ['h', 'e', 'l']

_, *b, _ = [4, 3, 5, 7]
print(b)  # [3, 5]

```

#### 函数传参解包

```python
def func(a, b, c):
    print(a, b, c)

tup = (1, 2, 3)
func(*tup)

d = {'a': 1, 'b': 2, 'c': 3}
func(**d)
```

* 在可迭代对象前面加一个星号（*），在字典对象前面加双星（**），这种解包方式主要运用在函数传参的过程中
```python
def func(a, b, c):
    print(a, b, c)
"""
在函数传实参时, *iterable可以将该iterable解包成位置参数
"""
tup = (1, 2, 3)
func(*tup)  # 等价于func(1, 2, 3)
d = {'a': 1, 'b': 2, 'c': 3}
func(*d)    # 等价于func('a', 'b', 'c')
"""
在函数传参时, **dict可以将该dict解包成关键字参数
"""
func(**d)  # 等价于func(a=1, b=2, c=3)
```

---

## 六、命名空间与作用域

### 1. 命名空间（Namespace）
* **定义**：命名空间（Namespace）是一个从名称到对象的映射
* **实现**：大部分命名空间当前由 Python 字典实现（内置命名空间由builtins模块实现）
* **作用**：提供了在项目中避免名字冲突的一种方法（各个命名空间是独立的，在一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响的）


#### 内置命名空间
* 包含了所有 Python 内置对象的名称
* 在解释器启动时创建，持续到解释器终止

#### 全局命名空间 
* 包含了模块中定义的名称，如：变量名、函数名、类名、其它导入的名称
* 在模块被读入时创建，持续到解释器终止

#### 局部命名空间
* 包含了函数中定义的名称，如：函数中的变量名、参数名
* 在函数被调用时创建，持续到该函数结束为止


```python
def func1(arg1, arg2):
    num = 666
    print(locals())

def func2(arg1, arg2):
    num = 777
    print(locals())

num = 111
func1(222, 333)
func2(444, 555)

print(globals())  # 全局命名空间
```

---

### 2. 命名空间查找顺序

```text
局部命名空间 >> 全局命名空间 >> 内置命名空间
```

---

## 七、作用域（Scope）

### 定义
Python 程序可以直接访问命名空间的正文区域

### 分类（LEGB规则）

| 缩写 | 名称        | 描述        |
| -- | --------- | --------- |
| L  | Local     | 局部作用域     |
| E  | Enclosing | 闭包函数外的函数中 |
| G  | Global    | 全局作用域     |
| B  | Built-in  | 内置作用域     |

---

### 示例：闭包函数作用域

```python
def outer(a):
    b = 2
    def inner(c):
        return a + b + c
    return inner

print(outer(1)(3))  # 输出 6
```

---

### 作用域关键字：`global` 与 `nonlocal`

```python
def outer():
    global a, b
    a, b, c, d = 3, 4, 5, 6
    print(a, b)

    def inner():
        global a, b
        nonlocal c, d
        a, b, c, d = 7, 8, 9, 0

    inner()
    print(c, d)

a, b = 1, 2
outer()
print(a, b)
```

* 规则：在当前作用域如果找不到对应名称，则去更大一级作用域去找，直到最后找不到就会报错
* 注意：模块、类以及函数会引入新的作用域，而条件语句，循环语句并不会
---
